""" automatic differentiation to find the spatial derivatives of the energy functional for a configuration specified by x"""
gradEnergy(x, Triangles, Psivals; args...) = ForwardDiff.gradient(x::Vector->EnergyFunctional(x::Vector, Triangles, Psivals), x)

""" Find the gradient corresponding to the Phi update using the deformation calculated by comparing Spher to Sphere0. An alternate method specifies the current configuration by a Nodes matrix rather than Spher """
function GradientPsi(psivals::Vector{Float64}, Spher::Spheroid, Sphere0::Spheroid)
    @assert Spher.Triangles == Sphere0.Triangles
    return GradientPsi(psivals, Spher.Nodes, Sphere0)
end
GradientPsi(psivals::Vector{Float64}, xvec::Vector{Float64}, Sphere0::Spheroid) = GradientPsi(psivals, xvec2Nodes(xvec), Sphere0)

function GradientPsi(psivals::Vector{Float64}, Nodes::Matrix{Float64}, Sphere0::Spheroid; n=10, K=2.0)
    FaceStretching = StretchingEnergies(Sphere0, Nodes)
    # return zeros(length(psivals))
    # return σ0*FaceStretching.^n./(K^n .+ FaceStretching.^n) - α*psivals
    return σ0*FaceStretching - α*psivals
end


""" Find the total gradient of a configuration as opposed to the reference configuration Sphere0"""
function gradEnergyPsi(xvec, Sphere0; noNodes::Int=noNodes)
    return [ForwardDiff.gradient(x::Vector->EnergyFunctional(x[1:3noNodes]::Vector, Sphere0.Triangles, xvec[3noNodes+1:end]), xvec[1:3noNodes]); GradientPsi(xvec[3noNodes+1:end], xvec[1:3noNodes], Sphere0)]
end

"""
    u is a vector of current positions (1:3noNodes) and Ψ values (3noNodes+1:end), p is the unperturbed sphere Sphere0
"""
function gradEnergyPsi!(du, u, p, t)
    xdiff = ForwardDiff.gradient(x::Vector->EnergyFunctional(x[1:3noNodes]::Vector, Sphere0.Triangles, u[3noNodes+1:end]), u[1:3noNodes])
    Ψdiff = GradientPsi(u[3noNodes+1:end], u[1:3noNodes], Sphere0)
    du[1:3noNodes] = xdiff
    du[3noNodes+1:end] = Ψdiff
    nothing
end

length(Sim::ODESimulation) = length(Sim.tvec)
function show(io::IO, Sim::ODESimulation)
    println(io, "A simulation generated by solving an ODE with Ψ, with $(size(Sim.Spherevec[1].Nodes)[1]) nodes and $(length(Sim.tvec)) timesteps")
end

PlotRadius(Sim::ODESimulation, j::Int; name="Distance from centre: t = $(Sim.tvec[j])") = PlotRadius(Sim.Spherevec[j]; name=name)
ShowPsi(Sim::ODESimulation, j::Int=length(Sim); args...) = ShowPsi(Sim.Spherevec[j]; args...)

"""
    Run the main gradient descent method through DifferentialEquations and save the result as a simulation
"""
function mainODE(Sphere::Spheroid, T::Float64; Sphere0::Spheroid=Sphere)
    t0 = time()
    tspan = (0., T)
    x0vec = [Nodes2xvec(Sphere.Nodes); Sphere.Psivals]
    # f(u, p, t) = -gradEnergyPsi(u, Sphere0)
    # prob = ODEProblem(f, x0vec, tspan)
    prob = ODEProblem(gradEnergyPsi!, x0vec, tspan)
    sol = solve(prob, Tsit5())
    println("Solution took $(round(time() - t0, digits=2)) seconds")
    return ODESimulation([Spheroid(xvec2Nodes(sol.u[j][1:3noNodes]), Sphere.Triangles, sol.u[j][3noNodes+1:end]) for j in 1:length(sol)], sol.t, time()-t0);
end

"""
    Continue a given simulation, this sometimes causes instabilities and I don't know why
"""
function ContinueSimulation(Sim::ODESimulation, T::Float64; Sphere0 = Sim.e[1])
    Sim2 = mainODE(Sim.Spherevec[end], T)
    return ODESimulation([Sim.Spherevec; Sim2.Spherevec], [Sim.tvec; Sim2.tvec .+ Sim.tvec[end]], Sim.RunTime+Sim2.RunTime)
end

function CheckEnergy(Sim::ODESimulation, j::Int; Loud::Bool=true)
    return EnergyFunctional(Sim.Spherevec[j].Nodes, Sim.Spherevec[j].Triangles, Sim.Spherevec[j].Psivals, Loud=Loud)
end

function PlotEnergy(Sim::ODESimulation; startat=1)
    Evals = [CheckEnergy(Sim, j, Loud=false) for j in startat:length(Sim)]
    return scatter(Sim.tvec[startat:end], Evals, axis=(yscale=log10,))
end


CompareCrossSections(Sim::ODESimulation, z::Number=0., tvals=1:10:101; args...) = CompareCrossSections([Sim.Spherevec[t] for t in tvals], z; names=["t = $t" for t in tvals], args...)